/* auther:carl
   date:2016.04.25*/

/*
一般按习惯将private:定义部分放在紧靠类名下面，并且“private:”可以省略。
“private:”下面定义的成员全是“私有”的，也就是只能在这个类的成员函数里可以使用，外部(包括派生的子类)不能使用。
“public:”下面定义的成员，所有地方都能使用。“protected:”下面定义的成员，在派生的子类中则相当于“public”，其它地方则相当于“private”。


构造函数和析构函数

“构造函数”是类产生实例时被调用，进行初始化设置，是一个特殊的成员函数，函数名与类名相同，没有返回值。
一般构造函数定义在“public:”下面，但有时为了阻止多个实例的产生而特意定义在“private:”或“protected:”下面。
当初始化时没有什么需要设定时也可以不定义，编译时会自动生成一个默认的构造函数。构造函数的重载使得实例的生成灵活而且方便，默认的构造函数没有参数，且是定义在“public:”下面的。

“析构函数”是类的实例被销毁时调用，进行最后的处理，例如释放动态分配的内存等。
一般析构函数定义在“public:”下面，不需要时也可以不定义，编译时会自动生成一个默认的析构函数。
析构函数的函数名与类名相同，前面有“~”返回值。

下面的例子演示构造函数和析构函数被调用的顺序。
*/

#include<iostream>
using namespace std;
class CA{
	int a;
public:
	CA(){
		a=0;
		cout<<"构造函数:"<<a<<endl;
	}
	~CA(){
		cout<<"析构函数:"<<a<<endl; 
	}
	void setA(int x){
        a = x;
	}	
	void print(){
		cout<<"print: "<<a<<endl;
	}
};

int main()
{
	CA ca;
	//ca.a = 10;    //成员变量a是私有的，不能直接访问
	ca.setA(10);
	ca.print();
	return 0;
}


